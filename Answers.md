<h1 align="center">Timus Full Stack Bootcamp Assignment-1</h1>

## 1. JavaScript nedir ve tarihsel gelişiminden bahsedin.

JavaScript (genellikle JS olarak kısaltılır), HTML ve CSS ile birlikte World Wide Web'in temel teknolojilerinden biri olan programlama dilidir. Web sitelerinin %97'sinden fazlası, web sayfası hareketleri için istemci tarafında JavaScript kullanırlar ve kullanılan kodlar genellikle üçüncü taraf kitaplıkları içerir. Tüm büyük web tarayıcılarında, kaynak kodunu kullanıcıların cihazlarında yürütebilmek için özel bir JavaScript motoru bulunur.

JavaScript, ECMAScript standardına uyan, genellikle eş zamanlı olarak derlenmiş, üst düzey bir dildir. Dinamik yazma, prototip tabanlı obje yönelimi ve birinci sınıf işlevlere sahiptir. Olay odaklı, işlevsel ve zorunlu programlama stillerini destekleyen çoklu paradigmadır. Metin, tarihler, düzenli ifadeler, standart veri yapıları ve Belge Obje Modeli (DOM) ile çalışmak için uygulama programlama arayüzlerine (API'ler) sahiptir.

### Tarihsel Gelişimi:

**1- İlk Gelişim (1995):** JavaScript, Netscape Navigator tarayıcısı için Brendan Eich tarafından 1995 yılında geliştirildi. İlk ismi "Mocha" olan bu dil, daha sonra "LiveScript" ve nihayetinde "JavaScript" olarak adlandırıldı.

**2- Standartlaşma (1997):** JavaScript, European Computer Manufacturers Association (ECMA) tarafından standartlaştırıldı ve ECMAScript adını aldı. ECMAScript, JavaScript dilinin resmi tanımını içerir.

**3- Tarayıcı Savaşları (1995-2005):** Microsoft'un Internet Explorer ve Netscape'in Navigator tarayıcıları arasındaki rekabet sırasında, tarayıcı özelliklerinde uyumsuzluklar ortaya çıktı. Bu durum, web geliştiricileri için sorunlara yol açtı.

**4- Ajax ve Web 2.0 (2000’lerin başları):** JavaScript, Asynchronous JavaScript and XML (Ajax) teknikleri sayesinde web uygulamalarında daha etkileşimli ve hızlı kullanıcı deneyimleri sunmaya başladı. Web 2.0 konsepti ile birlikte, JavaScript'in rolü daha da önemli hale geldi.

**5- JQuery ve Diğer Kütüphaneler (2000’lerin ortaları):** jQuery gibi kütüphaneler, JavaScript kodunu daha kolay ve tarayıcılar arası uyumluluğu artırarak yazmayı sağladı. Bu dönemde, birçok JavaScript çerçevesi ve kütüphanesi ortaya çıktı

**6- Node.Js ve Server-Side JavaScript (2009):** Ryan Dahl tarafından geliştirilen Node.js, JavaScript'i sadece tarayıcıda değil, sunucu tarafında da çalıştırmak için bir platform sağladı. Bu, JavaScript'in geniş bir kullanım alanına sahip olmasını sağladı.

**7- ECMAScript 6 (2015):** ES6 veya ECMAScript 2015, bir dizi yeni özellik, sözdizimi iyileştirmeleri ve modern programlama paradigmalarını ekleyerek JavaScript'i güçlendirdi.

**8- Modern Gelişmeler (Sonraki Yıllar):** Son yıllarda, JavaScript'in popülerliği giderek arttı. Framework'ler ve kütüphaneler arasında Angular, React, ve Vue.js gibi araçlar, modern web uygulamalarının geliştirilmesinde etkili bir şekilde kullanılıyor.

JavaScript, tarayıcılar dışında da kullanılabilecek bir dil haline gelmiş ve günümüzde birçok farklı platformda geniş bir kullanım alanına sahiptir. Bu süreçte, dilin evrimi, standartlarının gelişimi ve geliştirici topluluğunun katkıları büyük rol oynamıştır.

## 2. Java ile javascript arasındaki fark nedir?

Java ve JavaScript, isim benzerliklerine rağmen farklı programlama dilleridir ve farklı amaçlara hizmet ederler.Aralarındaki bazı farklar şunlardır:

**1. Tip:**

- Java, statik bir tipli dil olarak bilinir. Bu, değişkenlerin türlerinin derleme zamanında belirlendiği anlamına gelir.
- JavaScript ise dinamik bir tipli dil olarak bilinir. Değişkenlerin türleri çalışma zamanında belirlenir.

**2. Platform:**

- Java, genellikle bilgisayar programları, web uygulamaları, mobil uygulamalar ve büyük ölçekli sistemler gibi çeşitli platformlarda çalışabilen genel amaçlı bir dilidir.
- JavaScript, tarayıcı ortamında çalışan bir tarayıcı tabanlı bir dil olup, genellikle web sayfalarında kullanılır. Ancak, Node.js gibi ortamlarda sunucu tarafında da çalışabilir.

**3. Kullanım Alanları:**

- Java, geniş bir yelpazede uygulama geliştirmek için kullanılır. Mobil uygulamalardan büyük ölçekli kurumsal sistemlere kadar birçok farklı alanda kullanılabilir.
- JavaScript, genellikle web tarayıcıları üzerinde kullanılır. Kullanıcı arayüzü etkileşimini yönetmek, tarayıcıda dinamik içerik oluşturmak ve web sayfalarını canlandırmak için kullanılır

**4. Derleme ve Yürütme:**

- Java, bir kaynak kodunu derleyip ardından Java sanal makinesinde (JVM) çalıştırılabilir bir bytecode'a dönüştürür. Bu nedenle, Java uygulamaları JVM tarafından desteklenen herhangi bir platformda çalışabilir.
- JavaScript, tarayıcıda yürütülür ve genellikle tarayıcı tarafından yorumlanarak çalıştırılır. Ancak, Node.js gibi ortamlarda sunucu tarafında da çalışabilir.

**5. Sözdizimi ve Tasarım:**

- Java, C++ benzeri bir sözdizimine ve nesne yönelimli programlamaya dayanır.
- JavaScript, C ve Java'ya benzer bir sözdizimine sahip olsa da, prototip tabanlı nesne yönelimli programlamayı temel alır.

**6. Nesne Yönelimli Programlama (OOP):**

- Java, kuvvetli bir nesne yönelimli programlama dilidir ve sınıflar, nesneler ve kalıtım gibi OOP kavramlarını destekler.
- JavaScript, nesne tabanlı bir dil olup, ancak OOP özelliklerini sınırlı bir şekilde destekler.

Bu farklar, Java ve JavaScript'in farklı kullanım alanlarına ve tasarım felsefelerine sahip olduğunu gösterir. İki dilin benzer isimlerine rağmen, temelde farklı dillerdir ve farklı bağlamlarda kullanılırlar.

## 3. JavaScript'teki veri tipleri nelerdir? Açıklayınız.

JavaScript'te veri tutmak için kullanılan veri tiplerini **2 ayrı grupta** inceleyebiliriz.

- Basit (Primitive) Veri Tipleri

- Referans Veri Tipleri

### Basit (Primitive) Veri Tipleri

Primitive veri tipleri, JavaScript'te değerleri doğrudan içerir . Ayrıca, primitive veri tipleri bellekte bir kopyasını tutar, bu nedenle bir değişkenin değeri başka bir değişkene atandığında, orijinal değişkenin değeri değişmez. Bu, primitive veri tiplerinin "pass-by-value" (değer ile geçme) davranışına sahip olduğu anlamına gelir. Primitive veri tiplerinden bazıları şunlardır:

**1. Number (Sayı):**

- Tamsayılar veya ondalık sayıları ifade eder.

```JavaScript
	let integerNumber = 42;
	let floatingNumber = 3.14;
```

**2. String (Metin):**

- Metinsel verileri ifade eder.

```JavaScript
	let text = "Hello, World!";
```

**3. Boolean (Boolean):**

- Mantıksal değerleri temsil eder, sadece iki değer alabilir, `true` veya `false`.

```JavaScript
	let isTrue = true;
	let isFalse = false;
```

**4. Undefined (Tanımsız):**

- Bir değişkenin tanımlı olmadığı durumu ifade eder.

```JavaScript
	let undefinedVariable;
```

**5. Null (Boş):**

- Bir değişkenin değerinin bilinçli olarak boş olduğunu ifade eder.

```JavaScript
	let nullVariable = null;
```

**6. Symbol (Sembol):**

- Benzersiz ve değiştirilemez bir veri türüdür.

```JavaScript
	let symbol = Symbol("uniqueSymbol");
```

**7. BigInt (Büyük Tamsayı):**

- JavaScript'te sonradan eklenen bir veri türüdür ve çok büyük tamsayıları temsil etmek için kullanılır.

```JavaScript
	let bigInteger = BigInt(9007199254740991);
```

### Referans Veri Tipleri

Bu türler, JavaScript'te referans veri tiplerini temsil eder ve değerleri bellekte bir referans aracılığıyla tutulur. Bu, değişkenler arasında bu değerlerin paylaşılmasını ve referans üzerinden değiştirilebilmesini sağlar. Referans veri tiplerinden bazıları şunlardır:

**1. Object (Objeler):**

- `Object` türü, birçok veri türünü içeren karmaşık veri yapılarını temsil eder. Obje içindeki verilere "property" (özellik) denir ve bu özellikler, anahtar-değer çiftleri şeklinde tanımlanır.

```JavaScript
	let person = {
		name: "John",
		age: 30,
		isStudent: false
	};
```

**2. Array (Diziler):**

- `Array` türü, sıralı veri koleksiyonlarını temsil eder. Her öğe bir indeksle erişilebilir.

```JavaScript
    let numbers = [1, 2, 3, 4, 5];
    let fruits = ["elma", "armut", "çilek"];
```

**3. Function (Fonksiyonlar):**

- `Function` türü, JavaScript'te birinci sınıf nesnelerdir, yani bir değişken olarak atanabilir, bir fonksiyonun argümanı olabilir veya başka bir fonksiyon tarafından döndürülebilirler.

```JavaScript
	function  greet(name) {
		return  "Hello, " + name + "!";
	}
```

**4. Date (Tarih):**

- `Date` türü, tarih ve saat bilgilerini temsil eder.

```JavaScript
	let currentDate = new Date();
```

**5. Map ve Set:**

- `Map` ve `Set` türleri, koleksiyon veri türleridir. `Map` anahtar-değer çiftlerini saklar, `Set` ise benzersiz değerleri saklar.

```JavaScript
	let myMap = new  Map();
	myMap.set("key1", "value1");

	let mySet = new  Set();
	mySet.add("value1");
```

## 4. Null ve Undefined arasındaki fark nedir? Açıklayınız

`null` ve `undefined` JavaScript'te iki farklı değerdir, ancak kullanım amaçları birbirinden biraz farklıdır.

**`1. Undefined`:**

- `undefined`, bir değişkenin değerinin atanmamış olduğunu gösterir. Yani, bir değişken tanımlanmış ancak bir değer atanmamışsa, JavaScript otomatik olarak bu değişkenin değerini `undefined` yapar.

- Ayrıca, bir fonksiyonun geri dönüş değeri belirtilmediğinde veya bir fonksiyonun parametrelerinden birine değer atanmadığında da `undefined` elde edilir.

**`2. null`:**

- `null`, bir değişkenin bilinçli olarak boş olduğunu ifade eder. Yani, bir değişkenin değerini bilinçli olarak boşaltmak istiyorsanız, `null` kullanabilirsiniz.

- Genellikle, `null`'ı bir nesnenin beklenen değeri olmadığını ifade etmek veya bir değişkenin başlangıç değeri olarak atanmış bir boş değeri ifade etmek için kullanılır.

Özetle, `undefined` genellikle bir değişkenin henüz bir değer almadığını ifade ederken, `null` bir değişkenin bilinçli olarak boş olduğunu ifade eder. Her ikisi de JavaScript'te "falsy" değerlerdir, yani bir koşul ifadesinde false olarak değerlendirilirler.

## 5. NaN nedir? Açıklayınız

`NaN` (Not a Number), JavaScript'te bir özel değerdir ve "Sayı Değil" anlamına gelir. `NaN`, matematiksel bir işlemin sonucu sayı olmayan bir değer olduğunda ortaya çıkar. `NaN`, genellikle sayısal operasyonlarda hata durumlarını temsil etmek için kullanılır.

Birkaç durumda `NaN` elde edilebilir:

**1. Matematiksel İşlemlerde Hatalar:**

- Belirli matematiksel işlemler, tanımsız veya sınırsız sonuçlara yol açabilir ve bu durumda `NaN` elde edilir.

```JavaScript
	let result = 0 / 0; // NaN
```

**2. Sayısal Olmayan Veri Tipleriyle Matematiksel İşlemler:**

- Sayısal olmayan bir değerle matematiksel bir işlem yapıldığında, sonuç `NaN` olabilir.

```JavaScript
	let result = "hello" * 5; // NaN
```

**3. `NaN` ile Karşılaştırmalar:**

- Herhangi bir sayısal değer `NaN` ile karşılaştırıldığında sonuç genellikle `false` olur.

```JavaScript
	console.log(NaN === NaN); // false
```

- `NaN`, herhangi bir sayısal değerle eşit değildir, hatta kendisiyle bile eşit değildir. Bu nedenle, `NaN`'ı kontrol etmek için `isNaN()` fonksiyonu kullanılabilir.

```JavaScript
	console.log(isNaN(NaN)); // true
	console.log(isNaN("hello")); // true
	console.log(isNaN(42)); // false
```

## 6. JavaScript'te yorum satırı eklemenin kaç farklı yolu vardır?

JavaScript'te yorum eklemek için iki farklı yöntem vardır:

1.  **Tek Satırlık Yorum:**

- Tek satırlık yorumlar, `//` işaretiyle başlar ve o satırın sonuna kadar devam eder.

  ```JavaScript
      // Bu bir tek satırlık yorum örneğidir.
      let x = 5; // Bu da bir tek satırlık yorumdur.
  ```

2.  **Çok Satırlı Yorum:**

- Çok satırlı yorumlar `/*` ile başlar ve `*/` ile biter. İçinde birden fazla satırı kapsayabilir.

  ```JavaScript
      /* bu
      bir
      çok satırlı
      yorum örneğidir. */
  ```

  Yorumlar, kodunuzun okunabilirliğini artırmak ve kodu belgelemek için kullanılır. Programınızın anlaşılabilir olması ve başkaları tarafından kolayca takip edilebilmesi için düzenli olarak yorum eklemek iyi bir pratiktir.

## 7. Global değişken ne demektir? Açıklayınız

Global değişken, bir programın veya bir betik dosyasının genel kapsamında tanımlanan ve programın herhangi bir yerinde erişilebilen bir değişkendir. Global değişkenler, genellikle programın başlangıcında tanımlanır ve programın sonuna kadar yaşarlar.

Bir global değişken, genellikle fonksiyonlar, bloklar veya başka bir kapsam içinde değil, dosyanın veya betiğin en üst düzeyinde tanımlanır. Bu durumda, değişken tüm programın kapsamına dahil edilir.

Örnek:

```JavaScript
	var globalVariable = "Bu bir global değişkendir.";
	function  exampleFunction() {
		console.log(globalVariable); // Global değişkene burada erişilebilir.
	}

	exampleFunction(); // Çıktı: Bu bir global değişkendir.
	console.log(globalVariable); // Çıktı: Bu bir global değişkendir.
```

Bu örnekte `globalVariable`, fonksiyon içinde ve fonksiyon dışında erişilebilir. Ancak, global değişkenlerin aşırı kullanımı, programın karmaşıklığını artırabilir ve hata olasılıklarını artırabilir, bu nedenle dikkatlice kullanılmalıdır. Modern JavaScript uygulamalarında genellikle daha sınırlı kapsamlara sahip değişkenler kullanmak ve global kapsamdan kaçınmak önerilir.

## 8. Javascript’te 'this' anahtar kelimesi nedir? Açıklayınız.

JavaScript'te `this` anahtar kelimesi, belirli bir bağlamdaki (context) nesneyi referans alır. `this`, bir fonksiyonun içinde veya bir nesne içinde kullanıldığında, o anki bağlamı belirtir.

`this`'in değeri, fonksiyonun nasıl çağrıldığına bağlı olarak değişir. İki temel durumda `this`'in değeri belirlenir:

**1.Fonksiyonlar içinde:**

- Eğer bir fonksiyon bir nesne içinde çağrılıyorsa, `this`, o fonksiyonun çağrıldığı nesneyi referans alır.

  ```JavaScript
  let person = {
  	name: "John",
  	sayHello: function() {
  		console.log("Merhaba, ben " + this.name);
  	}
  };

  person.sayHello(); // Çıktı: Merhaba, ben John
  ```

**2.Global Kapsamda:**

- Eğer bir fonksiyon global kapsamda (bağlam dışında) çağrılıyorsa, `this`, genellikle `window` nesnesini referans alır (tarayıcı ortamında).

  ```JavaScript
  function  globalFunction() {
  	console.log(this); // Tarayıcıda: Window nesnesi
  }

  globalFunction();
  ```

`this`'in değeri, `call`, `apply`, veya `bind` gibi fonksiyonlarla özel olarak belirlenebilir. Bu yöntemlerle bir fonksiyonun `this` değeri belirli bir nesne olarak atanabilir.

Önemli bir not: Arrow (ok) fonksiyonları, kendi `this` bağlamını oluştururlar ve genellikle tanımlandıkları kapsamdaki `this`'i referans alırlar.

## 9. == ile === farkını örnekler ile açıklayınız.

JavaScript'te `==` (loose equality) ve `===` (strict equality) karşılaştırma operatörleri arasındaki temel fark, değerlerin eşit olup olmadığını kontrol ederken tip dönüşümü yapılıp yapılmayacağıdır.

### `==` (Loose Equality):

- `==` operatörü, değerleri karşılaştırırken tip dönüşümü yapabilir.
- Eğer değerler farklı türlerdeyse, JavaScript tip dönüşümü gerçekleştirip değerleri aynı türe çevirmeye çalışır.
  ```JavaScript
  console.log(5 == "5"); // true (Tip dönüşümü yapıldı, değerler eşit)
  console.log(true == 1); // true (Tip dönüşümü yapıldı, değerler eşit)
  console.log(null == undefined); // true (Tip dönüşümü yapıldı, değerler eşit)
  ```

### `===` (Strict Equality):

- `===` operatörü, değerleri karşılaştırırken tip dönüşümü yapmaz.
- Değerlerin türleri ve değerleri tam olarak eşleşmelidir.

  ```JavaScript
  console.log(5 === "5"); // false (Tür dönüşümü yapılmadı, değerler farklı)
  console.log(true === 1); // false (Tür dönüşümü yapılmadı, değerler farklı)
  console.log(null === undefined); // false (Tür dönüşümü yapılmadı, değerler farklı)
  ```

  ```JavaScript
  let obj1 = { name: "John" };
  let obj2 = { name: "John" };

  console.log(obj1 == obj2); // false (Referanslar farklı, değerlere bakılmaz)
  console.log(obj1 === obj2); // false (Referanslar farklı, değerlere bakılmaz)
  ```

  Bu örnekte, `obj1` ve `obj2` farklı referanslara sahip iki farklı nesnedir. `===` kullanıldığında, referanslar karşılaştırıldığı için sonuç `false` olur.

  ```JavaScript
  let arr1 = [1, 2, 3];
  let arr2 = [1, 2, 3];

  console.log(arr1 == arr2); // false (Referanslar farklı, değerlere bakılmaz)
  console.log(arr1 === arr2); // false (Referanslar farklı, değerlere bakılmaz)
  ```

  Bu örnekte, `arr1` ve `arr2` farklı referanslara sahip iki farklı dizi. `===` kullanıldığında, referanslar karşılaştırıldığı için sonuç `false` olur.

  `===` operatörü, nesne ve dizilerde değerlere bakmaz, yalnızca referansları karşılaştırır. Bu nedenle, eğer değerlere dayalı bir karşılaştırma yapmak istiyorsanız, özel bir karşılaştırma fonksiyonu kullanmanız veya içeriklerini ayrı ayrı kontrol etmeniz gerekir.

  Genel olarak, mümkünse `===` operatörünü kullanmak, tip dönüşümü olmadan sıkı bir eşitlik kontrolü yapmanızı sağlar ve beklenmeyen sonuçları önleyebilir. Ancak, belirli durumlarda tip dönüşümü isteniyorsa veya gerekliyse, `==` kullanılabilir.

## 10. let var const farkını tablo yapınız.

`let`, `var` ve `const` farklarını gösteren tablo aşağıda verilmiştir. (Y=Yes, N=No)

<p align="center">  <img src="https://miro.medium.com/v2/resize:fit:972/1*vgxOaRGDfCF6ImIo6Faubw.png" alt="let-var-const tablosu">  </p>

## 11. Arrow fonksiyonun normal fonksiyondan farkları nelerdir?

Arrow fonksiyonları (ok fonksiyonları) ve normal fonksiyonlar (fonksiyon ifadeleri ve fonksiyon deklarasyonları) arasında birkaç fark vardır. Bu farklardan bazıları şunlardır:

**1. `this` Bağlamı:**

- Arrow fonksiyonları, kendi `this` bağlamını oluştururlar ve dış kapsamdaki `this`'i alırlar. Bu, arrow fonksiyonlarıyla oluşturulan fonksiyonlarda `this`'in dinamik değişmediği anlamına gelir.

  ```JavaScript
    let person = {
        name: "John",
        sayHello: function() {
            console.log("Merhaba, ben " + this.name);
        }
    };

    person.sayHello(); // Çıktı: Merhaba, ben John

    let person = {
        name: "John",
      	sayHello: () => {
      		console.log("Merhaba, ben " + this.name);
      	}
      };

      person.sayHello(); // Çıktı: Merhaba, ben undefined
  ```

  **2. Argümanlar (arguments) Objesi:**

- Arrow fonksiyonları `arguments` nesnesini tanımlamazlar. Ancak, normal fonksiyonlar bu nesneyi kullanabilir.

  ```JavaScript
  let normalFunction = function() {
  	console.log(arguments); // [1, 2, 3]
  };
  let  arrowFunction = () => {
  	console.log(arguments); // ReferenceError: arguments is not defined };

  normalFunction(1, 2, 3);
  // arrowFunction(1, 2, 3); // Hata: arguments is not defined
  ```

**3. `new` İle Kullanım:**

- Arrow fonksiyonları, `new` ile kullanılmak üzere tasarlanmamışlardır. Yani, arrow fonksiyonları constructor olarak kullanılamazlar.

  ```JavaScript
  let NormalConstructor = function() {
    this.value = 1;
  };

  let normalInstance = new NormalConstructor();
  console.log(normalInstance.value); // 1

  let ArrowConstructor = () => {
    this.value = 1;
  };

  let arrowInstance = new ArrowConstructor(); // Hata: ArrowConstructor is not a constructor
  ```

  Bu farklar göz önüne alındığında, arrow fonksiyonlarının daha kısa sözdizimi ve`this` bağlamındaki davranışı nedeniyle özellikle callback fonksiyonlarında ve kısa işlevsel ifadelerde tercih edildiğini görebiliriz. Ancak, kullanım senaryolarına bağlı olarak normal fonksiyonlar da gereklidir.

## 12. Switch bloğu içinde hatasız nasıl değişken tanımlanır?

`switch` bloğu içinde bir değişken tanımlamak, genellikle tercih edilmeyen bir pratiktir çünkü `switch` bloğu, bir değerin farklı durumlarını kontrol etmek için kullanılır ve her durum için ayrı bir kod bloğu içerir. Değişken tanımlamak, her bir durumun kod bloğunun içinde genellikle işlevsiz olacaktır çünkü değişkenin kapsamı sadece o durumun içinde olacaktır.

Ancak, eğer bu işlemi gerçekten yapmak istiyorsanız, `let` veya `var` kullanabilirsiniz. Ancak, bu durumda değişkenin kapsamı sadece o durum içinde geçerli olacaktır ve başka durumlar veya bloklar tarafından erişilemeyecektir. Ayrıca hata almamak için tanımlanacak olan değişkenin süslü parantezler içine alınması gerekir. Bu durumun bir örneği aşağıda verilmiştir.

```JavaScript
switch (state) {
	case  'active': {
		let message = 'Durum aktif.';
		console.log(message);
		break;
	}
	case  'passive': {
		let message = 'Durum pasif.';
		console.log(message);
		break;
	}
	default: {
		let message = 'Bilinmeyen durum.';
		console.log(message);
	}
}
```

Ancak, yukarıdaki örnekte görebileceğiniz gibi, her durum için ayrı bir `message` değişkeni tanımlamak, genellikle gereksiz bir karmaşıklığa neden olabilir. Genellikle, `switch` bloğu içinde değişken tanımlamak yerine, `switch` bloğu dışında bir değişken tanımlayıp onu içinde kullanmak daha temiz bir kod yapısı sağlar.

## 13. Pure fonksiyon ne demektir? Açıklayınız.

Bir fonksiyonun "pure" (saf) olması, iki ana özelliğe dayanır: belirli bir girdi seti için her zaman aynı çıktıyı üretir ve yan etkileri yoktur. İlk özelliğe referansla, aynı girdi değerleriyle çağrılan bir saf fonksiyon her zaman aynı sonucu üretmelidir. İkinci özellikle ilgili olarak, fonksiyonun diğer program bileşenleri üzerinde bir etkisi olmamalıdır, yani dış dünyada değişikliklere neden olmamalıdır.

Saf fonksiyonlar, programlamada özellikle fonksiyonel programlama paradigmasında önemli bir konsepttir. Bu tür fonksiyonlar, hata ayıklamayı kolaylaştırır, test edilebilirliği artırır ve programın daha tahmin edilebilir olmasını sağlar.

Örneğin, aşağıdaki JavaScript fonksiyonu bir saf fonksiyon örneğidir:

```JavaScript
function  sum(a, b) {
	return a + b;
}
```

Bu fonksiyon her zaman aynı girdi değerleriyle çağrıldığında aynı sonucu üretir ve herhangi bir yan etkisi yoktur. Diğer bir deyişle, dış dünyada herhangi bir durumu değiştirmez.

## 14. Rest operatör nedir? Örnekle açıklayınız.

Rest operatörü, JavaScript'te bir dizi içindeki geri kalan elemanları bir değişkene atamak veya bir fonksiyona parametre olarak iletmek için kullanılan bir operatördür. Genellikle üç nokta (`...`) ile ifade edilir.

Rest operatörü, bir dizi içindeki belirli elemanları almak yerine, geri kalan elemanları bir başka değişkene toplar. Aşağıda bir örneği verilmiştir.

```JavaScript
const [firstElement, secondElement, ...restElements] = [1, 2, 3, 4, 5];

console.log(firstElement); // 1
console.log(secondElement); // 2
console.log(restElements); // [3, 4, 5]
```

Bu örnekte, `...restElements` rest operatörü kullanılarak dizinin geri kalan elemanları bir dizi olarak alınmıştır.

Aynı rest operatörü fonksiyon parametrelerinde de kullanılabilir. Örneğin:

```JavaScript
function  sum(...numbers) {
	return numbers.reduce((sum, num) => sum + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

Bu örnekte, `...numbers` rest operatörü, fonksiyona geçilen tüm sayıları bir dizi olarak toplar. `reduce` fonksiyonu kullanılarak bu sayılar toplanır. Bu, fonksiyonun herhangi bir sayı miktarını alabilmesini sağlar.

## 15. Object destructuring nedir? Örnekle açıklayınız.

Object destructuring, JavaScript'te bir nesne içindeki özellikleri ayrıştırarak, bunları ayrı değişkenlere atamak için kullanılan bir özelliktir. Bu, nesne içindeki özelliklere daha kolay erişim sağlar ve kodu daha okunabilir hale getirir.

Aşağıda bir örnek verilmiştir.

```JavaScript
const user = {
	name: 'John',
	surname: 'Doe',
	age: 30
};

// Object destructuring kullanarak nesne özelliklerini ayrıştırma
const { name, surname, age } = user; // Ayrıştırılmış değerleri kullanma

console.log(name); // 'John'
console.log(surname); // 'Doe'
console.log(age); // 30
```

Bu örnekte, `user` adında bir nesne var ve `const { name, surname, age } = user;` satırında object destructuring kullanılarak nesne özellikleri ayrıştırılmıştır. Bu sayede `name`, `surname` ve `age` adında üç ayrı değişken oluşturulmuş ve bunlara sırasıyla "John", "Doe" ve 30 değerleri atanmıştır.

Object destructuring, özellikle fonksiyonlardan dönen nesnelerden belirli özellikleri çıkarmak veya nesne içindeki özelliklere daha kolay erişim sağlamak için yaygın olarak kullanılır.

## 16. 2 elemanlı bir objeyi 6 farklı şekilde oluşturunuz.

**1. Objeyi Direkt Oluşturma:**

```JavaScript
const obj1 = { name: 'John', age: 25 };
```

**2. Objeyi `Object` Constructor'ıyla Oluşturma:**

```JavaScript
const obj2 = new Object({ name: 'Jane', age: 30 });
```

**3. Objeyi `Object.create()` ile Oluşturma:**

```JavaScript
const prototypeObj = { name: 'Charlie', age: 35 };
const obj3 = Object.create(prototypeObj);
```

**4. Objeyi `Object.assign()` ile Oluşturma:**

```JavaScript
const targetObj= {};

const sourceObj1= { name: 'John' };
const sourceObj2= { age: 25 };

Object.assign(targetObj, sourceObj1, sourceObj2);
console.log(targetObj);
```

**5. Objeyi Fonksiyon ile Oluşturma:**

```JavaScript
function  createObject(name, age) {
	return {name, age};
}

const obj5 = createObject('David', 40);
```

**6. Class Kullanarak Obje Oluşturma:**

```JavaScript
class myObject  {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
let obj6 = new myObject("John", 25);
```

## 17. 2 elemanlı bir objenin key ve value değerlerinin karakter sayısı ile 2 farklı döngü methodu kullanarak yeni bir obje oluşturunuz.

Aşağıda iki farklı döngü methodu kullanarak bir objenin key ve value değerlerinin karakter sayısı ile yeni bir obje oluşturan örnek bir JavaScript kodu bulunmaktadır:

```javascript
const originalObj = {
  name: "John",
  age: 25,
};

// 1. Döngü Methodu: for...in Döngüsü
const newObj1 = {};
for (let key in originalObj) {
  newObj1[key] = originalObj[key].length;
}

// 2. Döngü Methodu: Object.keys() ve forEach
const newObj2 = {};
Object.keys(originalObj).forEach((key) => {
  newObj2[key] = originalObj[key].length;
});

console.log(newObj1);
console.log(newObj2);
```

Bu örnekte, `originalObj` adında bir obje var. İki farklı döngü methodu kullanılarak her bir key'in değerinin karakter sayısı ile yeni bir obje oluşturuluyor. `newObj1` ve `newObj2` sonuç olarak aşağıdaki gibi olacaktır:

```javascript
//  newObj1
{ name:  4, age:  2 }

//  newObj2
{ name:  4, age:  2 }
```

## 18. Cookie, local storage ve session storage farkını tablo yapınız.

Cookie, local storage ve session storage farkları tablosu aşağıda verilmiştir.

<p align="center"><img src = "https://i.stack.imgur.com/6EL55.png"/>
</p>

## 19. Asenkron ve senkron işlem farkı nedir?

Senkron ve asenkron işlemler arasındaki temel fark, işlemlerin nasıl gerçekleştiği ve birbirleriyle nasıl etkileşimde bulunduklarıdır.

**1. Senkron İşlemler:**

- Senkron işlemlerde, işlemler sırasıyla ve adım adım gerçekleşir. Bir işlem tamamlanmadan diğeri başlamaz.
- İşlemler, sıralı bir şekilde yürütülür ve bir işlemin tamamlanması diğerine geçilmeden beklenir.
- Senkron işlemler genellikle basit ve doğrusal problemler için uygundur.

**2. Asenkron İşlemler:**

- Asenkron işlemlerde, işlemler eşzamansız olarak çalışır. Bir işlem tamamlanırken diğer işlemler aynı anda devam edebilir.
- İşlemler arasında bağımlılık yoktur ve bir işlem tamamlandığında bir callback veya promise kullanılarak diğer işlemlere geçilebilir.
- Asenkron işlemler genellikle ağ çağrıları, dosya okuma/yazma, kullanıcı etkileşimleri gibi uzun süreli işlemler için uygundur.

Senkron işlemler genellikle daha basit ve doğrusal problemler için uygunken, asenkron işlemler daha karmaşık ve uzun süreli görevler için daha uygundur. Modern web geliştirmesi genellikle asenkron yapıda olup, kullanıcı etkileşimleri ve ağ çağrıları gibi işlemleri ele almak için asenkron programlama prensiplerini benimser.

## 20. Promise nedir ve neden ihtiyaç duyarız?

Promise, JavaScript'te asenkron programlamayı daha etkili ve okunabilir hale getiren bir nesnedir. Promise, bir değeri temsil eden ve gelecekte tamamlanacak bir asenkron işlemi temsil eden bir objedir. Bir işlem tamamlandığında ya da hata oluştuğunda, Promise bu durumu temsil eden bir değeri döner.

Promise'ler, özellikle ağ çağrıları, dosya okuma/yazma, veritabanı sorguları gibi uzun süreli işlemleri ele almak için kullanılır. Promise'lerin neden önemli olduğuna dair bazı nedenler şunlardır:

1.  **Asenkron İşlemlerin Daha Okunabilir Kodlarla Yönetilmesi:** Promise'ler, asenkron işlemleri daha okunabilir ve yönetilebilir hale getirir. Callback hell (callback cehennemi) olarak adlandırılan derinleşen callback yapılarından kaçınmamıza yardımcı olur.
2.  **İşlemlerin Sıralı Yürütülmesi:** Promise'ler, işlemleri sıralı bir şekilde yürütmek ve bir işlem tamamlandığında diğerine geçmek için kullanılabilir. Bu, program akışını daha iyi kontrol etmeyi sağlar.
3.  **Hata Yönetimi:** Promise'ler, hata yönetimini daha etkili bir şekilde gerçekleştirmemize olanak tanır. `.then()` ve `.catch()` yöntemleri sayesinde başarılı ve başarısız durumları yönetebiliriz.
4.  **Birden Çok Asenkron İşlemin Koordinasyonu:** Birden çok asenkron işlemin koordinasyonu, Promise zincirleri kullanılarak daha düzenli bir şekilde sağlanabilir. Bu, özellikle bir dizi asenkron işlemin sırasını ve koşullarını kontrol etmek için önemlidir.

Örneğin, bir ağ çağrısının sonucunu beklemek için bir Promise kullanabiliriz. Aşağıda basit bir örnek verilmiştir:

```javascript
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { message: "Veri başarıyla alındı" };
      resolve(data); // Başarılı durum
      // reject('Hata: Veri alınamadı'); // Hata durumu
    }, 2000);
  });
};

fetchData()
  .then((data) => {
    console.log(data.message);
  })
  .catch((error) => {
    console.error(error);
  });
```

Bu örnekte, `fetchData` fonksiyonu bir Promise döndürüyor ve `.then()` ve `.catch()` yöntemleri kullanılarak başarılı ve başarısız durumlar yönetiliyor. Bu, asenkron işlemlerin daha düzenli bir şekilde ele alınmasına olanak tanır.

<h1  align="center">Array Soruları</h1>

## `var dolap = ["Shirt", "Pant", "Tshirt"]`;

## 1. dolap arrayindeki son elemanı silip consola yazdırın.

`dolap` arrayindeki son elemanı silip konsola yazdıran kod bloğu aşağıda verilmiştir.

```javascript
let lastElement = dolap.pop();
console.log(lastElement); // "Tshirt"
```

## 2. dolap arrayindeki ilk elamanı silip yerine “Hat” elemanını gönderip consola yazdırın.

`dolap` arrayingdeki ilk elemanı silip yerine "Hat" elemanını ekleyecek kod bloğu aşağıda verilmiştir.

```javascript
dolap.splice(0, 1, "Hat");
console.log(dolap); // [ 'Hat', 'Pant', 'Tshirt' ]
```

## 3. dolap değişkeninin array olup olmadığını kontrol edin ve sonucu bir değişkene eşitleyin.

`dolap` değişkeninin array olup olmadığını kontrol eden ve sonucu bir değişkene eşitleyen kod bloğu aşağıda verilmiştir.

```javascript
const isArr = Array.isArray(dolap);
console.log(isArr); // true
```

## 4. dolap arrayinde “Pant” elemanın olup olmadığını 3 farklı method ile kontrol edin.

`dolap` arrayine "Pant" elemanının olup olmadığını 3 farklı methodla kontrol eden kod bloğu aşağıda verilmiştir.

```javascript
const method1 = dolap.includes("Pant");
console.log(method1); // true

const method2 = dolap.find((el) => el === "Pant");
console.log(method2); // Pant
//Eğer elemanı bulamazsa undefined değerini döndürür.

const method3 = dolap.findIndex((el) => el === "Pant");
console.log(method3); // 1
//Eğer elemanı bulamazsa -1 değerini döndürür.
```

## 5. dolap arrayindeki elemanların karakter sayısını toplayıp geriye döndürecek fonksiyonu yazın.

`dolap` arrayindeki elemanların karakter sayısını toplayıp geriye döndürecek fonksyon aşağıda verilmiştir:

```javascript
function summingArray() {
  let num = dolap.reduce((acc, cur) => {
    let sum = acc + cur.length;
    return sum;
  }, 0);
  return num;
}

console.log(summingArray()); // 15
```

## 6. dolap arrayindeki tüm elemanları büyük harfe çevirip yeni bir değişkene 3 farklı yöntemle atayın.

`dolap` arrayindeki tüm elemanları büyük harfe çevirip yeni bir değişkene atacak olan 3 yöntem aşağıda verilmiştir.

```javascript
// map ve toUpperCase() kullanarak
const dolapUpper = dolap.map((el) => el.toUpperCase());
console.log(dolapUpper); // ["SHIRT", "PANT", "TSHIRT"]
```

```javascript
// for döngüsü kullanarak
const dolapUpper2 = [];
for (let i = 0; i < dolap.length; i++) {
  dolapUpper2.push(dolap[i].toUpperCase());
}
console.log(dolapUpper2); // ["SHIRT", "PANT", "TSHIRT"]
```

```javascript
// forEach kullanarak
const dolapUpper3 = [];
dolap.forEach((el) => dolapUpper3.push(el.toUpperCase()));
console.log(dolapUpper3); // ["SHIRT", "PANT", "TSHIRT"]
```

## dolap arrayini index sayıları key olacak şekilde objeye çeviriniz.

dolap arrayini index sayıları key olacak şekilde objeye çeviren kod bloğu aşağıda verilmiştir.

```javascript
const dolapObj = dolap.reduce((acc, cur, index) => {
  acc[index] = cur;
  return acc;
}, {});

console.log(dolapObj);
```

Bu örnekte, `reduce` fonksiyonu kullanılarak bir obje oluşturuyoruz. Her elemanı objeye eklerken, elemanın bulunduğu index'i key olarak kullanıyoruz. Sonuç olarak, `dolapObj` aşağıdaki gibi olacaktır:

```javascript
{
	0: "Shirt",
	1: "Pant",
	2: "Tshirt"
}
```

## 8. slice ile splice farkı nedir?

`slice` ve `splice` iki farklı dizi metodudur ve farklı amaçlara hizmet ederler:

**`slice()` Metodu:**

- `slice` metodunu kullanarak bir dizinin belirli bir bölümünü alabiliriz. Bu metod orijinal diziyi değiştirmez, sadece belirtilen bölümün bir kopyasını oluşturur.
- Parametre olarak başlangıç ve bitiş indekslerini alır. Başlangıç indeksi dahil, bitiş indeksi hariçtir.

**`splice()` Metodu:**

- `splice` metodunu kullanarak bir diziyi değiştirebiliriz. Bu metod, bir dizinin belirli bir bölümünü çıkarabilir ve/veya yeni elemanlar ekleyebilir.
- Parametre olarak başlangıç indeksi, kaç elemanın çıkarılacağı (opsiyonel) ve eklenen elemanlar alır.
- `splice` metodu orijinal diziyi değiştirir.

## `const arr = [1,2,3,4,5,6,7,7,8,6,10]; `

## 1. Arrayindeki yinelenen sayıları bulun

```javascript
const repeatedValues = [
  ...new Set(arr.filter((item, index) => arr.indexOf(item) !== index)),
];
console.log(repeatedValues); // [6, 7]
```

Bu örnekte, `Set` kullanarak yinelenen öğeleri filtreliyoruz. `filter` fonksiyonu ile, her bir öğenin dizideki ilk indeksi ile mevcut indeksi karşılaştırarak yinelenen öğeleri buluyoruz. Daha sonra, `Set` kullanarak bu yinelenen öğeleri tekrar bir diziye dönüştürüyoruz. Bu sayede, yinelenen sayıları elde etmiş oluyoruz.

## 2. Arrayindeki tüm yinelenen sayıları silip yeni bir arrayi 2 farklı method ile oluşturun.

```javascript
// filter ve indexOf() ile
const arr = [1, 2, 3, 4, 5, 6, 7, 7, 8, 6, 10];
const newArr1 = arr.filter((eleman, index) => arr.indexOf(eleman) === index);
console.log(newArr1); // [1, 2, 3, 4, 5, 6, 7, 8, 10 ]
```

```javascript
// Set ile
const arr = [1, 2, 3, 4, 5, 6, 7, 7, 8, 6, 10];
const newArr2 = [...new Set(arr)];
console.log(newArr2); // [1, 2, 3, 4, 5, 6, 7, 8, 10]
```

## 3. Arrayindeki en yüksek ve en düşük değeri 2 farklı methodla bulun.

```javascript
// Math ve Spread operatörü ile
const arr = [1, 2, 3, 4, 5, 6, 7, 7, 8, 6, 10];

const max1 = Math.max(...arr);
const min1 = Math.min(...arr);

console.log(max1); // 10
console.log(min1); // 1
```

```javascript
// reduce ile
const arr = [1, 2, 3, 4, 5, 6, 7, 7, 8, 6, 10];

const { max2, min2 } = arr.reduce(
  (acc, value) => {
    acc.max2 = Math.max(acc.max2, value);
    acc.min2 = Math.min(acc.min2, value);
    return acc;
  },
  { max2: Number.NEGATIVE_INFINITY, min2: Number.POSITIVE_INFINITY }
);

console.log(max2); // 10
console.log(min2); // 1
```

## Bu kodun çıktısı nedir? Neden?

```javascript
function job() {
  return new Promise(function (resolve, reject) {
    reject();
  });
}

let promise = job();

promise
  .then(function () {
    console.log("Success 1");
  })
  .then(function () {
    console.log("Success 2");
  })
  .then(function () {
    console.log("Success 3");
  })
  .catch(function () {
    console.log("Error 1");
  })
  .then(function () {
    console.log("Success 4");
  });
```

Yukarıda başarısız bir promise döndüren bir `job()` fonksyonu tanımlanmıştır. Bu yüzden ilk üç `.then()` bloğuna girmeyecek ve direkt `.catch()` bloğuna girilecektir. `.catch()` işlemi tamamlandıktan sonra peşinden gelen `.then()` bloğuna girilecektir. Program tamamlandığında çıktı şu şekilde görünecektir:

```javascript
"Error 1";
"Success 4";
```

## Bu kodun çıktısı nedir? Neden?

```javascript
function job(state) {
  return new Promise(function (resolve, reject) {
    if (state) {
      resolve("success");
    } else {
      reject("error");
    }
  });
}

let promise = job(true);

promise
  .then(function (data) {
    // 1.then bloğu
    console.log(data);

    return job(true);
  })
  .then(function (data) {
    // 2.then bloğu
    if (data !== "victory") {
      throw "Defeat";
    }
    return job(true);
  })
  .then(function (data) {
    // 3.then bloğu
    console.log(data);
  })
  .catch(function (error) {
    // 4.catch bloğu
    console.log(error);

    return job(false);
  })
  .then(function (data) {
    // 5.then bloğu
    console.log(data);

    return job(true);
  })
  .catch(function (error) {
    // 6.catch bloğu
    console.log(error);

    return "Error caught";
  })
  .then(function (data) {
    // 7.then bloğu
    console.log(data);

    return new Error("test");
  })
  .then(function (data) {
    // 8.then bloğu
    console.log("Success:", data.message);
  })
  .catch(function (data) {
    // 9.catch bloğu
    console.log("Error:", data.message);
  });
```

Yukarıda girilen parametreye göre `resolve()` ve ya `reject()` döndüren bir `job()` fonksiyonu tanımlanmıştır.

İlk gelen promise `resolve` olduğu için `1. then bloğu` 'na girilip `success` yazdırılacaktır.

Buradan dönen promise `resolve` olduğu için `2.then bloğu` 'na girilecektir. Burada `if` yapısının içine girilip bir `Defeat` erroru fırlatılacaktır. buradan error döndüğü için bu error `4.catch bloğu`'nda yakalanıp `Defeat` yazdırılacaktır.

Buradan dönen promise `reject` olduğu için `6.catch bloğu`'nun içine girilip `error` yazdırılacaktır.

Buradan bir string döndüğü için `7.then bloğu`'na girilip `Error caught` yazdırılacaktır.

Buradan Error("test") objesi döndürüldüğü için(fırlatılmadığı için) `8.then bloğu`'na girilecek ve `Success: test` yazdırılacaktır.

Programın sonunda çıktı şu şekilde görünecektir.

```javascript
success
Defeat
error
Error caught
Success: test
```
